import { Message } from "whatsapp-web.js";
import { promiseTracker } from "../clients/prompt";
import { sydney } from "../clients/sydney";
import { config } from "../config";

function generateSourcesString(
  sourceAttributions: SourceAttribution[]
): string {
  let seeMoreString = "\n\n";

  for (let i = 0; i < sourceAttributions.length; i++) {
    const attribution = sourceAttributions[i];
    seeMoreString += `[${i + 1}]: ${attribution.seeMoreUrl}\n`;
  }

  return seeMoreString;
}

async function handleIncomingMessageImpl(message: Message) {
  const chat = await message.getChat();
  const prompt = message.body;

  chat.sendSeen();

  try {
    const { response, details } = await promiseTracker.track(
      prompt,
      chat,
      askSydney(prompt, chat.id._serialized)
    );
    console.log("Sydney's response: ", response);

    const hasSources = details.sourceAttributions.length >= 1;
    const sources = hasSources
      ? generateSourcesString(details.sourceAttributions)
      : "";

    await message.reply(response + sources);
    chat.clearState();
  } catch (error) {
    await message.reply(
      `Error when answering this message.\n\nDetails: ${JSON.stringify(error)}`
    );
  }
}

async function askSydney(prompt: string, chatId: string) {
  let options: IOptions = {
    toneStyle: config.toneStyle,
    jailbreakConversationId: chatId,
    context: `User name is ${process.env.USER_NAME}, and your name is ${process.env.BOT_NAME}. If the user tells you to call him with another name or tells you have a new name, then give priority to the new name. Don't mention neither the user name nor your name everytime, only if it makes sense in your chat. Only present yourself once or if the user asks.`,
    // onProgress: (token: string) => {
    //  process.stdout.write(token);
    // }
  };

  const onGoingConversation = await sydney.conversationsCache.get(chatId);

  if (onGoingConversation) {
    const [{ parentMessageId }] = onGoingConversation.messages.slice(-1);
    options.parentMessageId = parentMessageId;
  }

  const response: SydneyResponse = await sydney.sendMessage(prompt, options);
  // console.dir(response, { depth: null });
  return response;
}

// generated by GPT-4, this ensures the typing indicator will last more than 25s
function typingIndicatorWrapper(fn: (message: Message) => Promise<void>) {
  return async (message: Message) => {
    const chat = await message.getChat();
    let interval: NodeJS.Timeout = setTimeout(() => {}, 0);

    const typingIndicator = () => {
      chat.sendStateTyping();
      interval = setTimeout(typingIndicator, 25000);
    };

    typingIndicator();

    try {
      const result = await fn(message);
      clearTimeout(interval);
      return result;
    } catch (error) {
      clearTimeout(interval);
      throw error;
    }
  };
}

export const handleIncomingMessage = typingIndicatorWrapper(
  handleIncomingMessageImpl
);

interface IOptions {
  toneStyle: (typeof config.VALID_TONES)[number];
  systemMessage?: string;
  jailbreakConversationId?: string;
  parentMessageId?: string;
  context?: string;
  onProgress?: (token: string) => void;
}

// these interfaces were generated by GPT-3.5 based on an example response
interface AdaptiveCard {
  type: string;
  version: string;
  body: Array<{
    type: string;
    text: string;
    wrap?: boolean;
    size?: string;
  }>;
}

interface SourceAttribution {
  providerDisplayName: string;
  seeMoreUrl: string;
  imageLink: string;
  imageWidth: string;
  imageHeight: string;
  imageFavicon: string;
  searchQuery: string;
}

interface Feedback {
  tag: null;
  updatedOn: null;
  type: string;
}

interface SuggestedResponse {
  text: string;
  author: string;
  createdAt: string;
  timestamp: string;
  messageId: string;
  messageType: string;
  offense: string;
  feedback: Feedback;
  contentOrigin: string;
  privacy: null;
}

interface Details {
  text: string;
  author: string;
  createdAt: string;
  timestamp: string;
  messageId: string;
  requestId: string;
  offense: string;
  adaptiveCards: AdaptiveCard[];
  sourceAttributions: SourceAttribution[];
  feedback: Feedback;
  contentOrigin: string;
  privacy: null;
  suggestedResponses: SuggestedResponse[];
}

interface SydneyResponse {
  conversationId: string;
  conversationSignature: string;
  clientId: string;
  invocationId: number;
  conversationExpiryTime: string;
  response: string;
  details: Details;
  jailbreakConversationId: string;
  parentMessageId: string;
  messageId: string;
}
